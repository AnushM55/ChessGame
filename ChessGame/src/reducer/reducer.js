import { Status } from "../constant";
import actionTypes from "./actionTypes";
import { calculateCombinedBitboards } from "../bitboard"; // Keep for TAKE_BACK maybe?
import { executeMove } from "../arbiter/makeBitboardMove"; // Import the move execution function
import { initGameState } from "../constant"; // Import initial state for NEW_GAME

export const reducer = (state, action) => {
  switch (action.type) {
    case actionTypes.NEW_MOVE: {
      console.group('NEW_MOVE Action');
      console.log('Incoming move:', action.payload);
      
      // Expect payload to be the validated move object: { from, to, piece, ... }
      const move = action.payload;
      let { history, movesList } = state;

      // Get the current state from the latest history entry
      const currentGameState = history[history.length - 1];

      // Log pre-move state
      console.log('Pre-move bitboards:', JSON.stringify(currentGameState.bitboards, (_, v) => 
          typeof v === 'bigint' ? v.toString() : v, 2));
      
      // Execute the move to get the relevant parts of the next state
      const {
          newBitboards,
          newOccupied,
          newWhitePieces,
          newBlackPieces,
          newCastleDirection,
          newEnPassantTargetSq,
          newMoveNotation // Generated by executeMove
      } = executeMove(currentGameState, move);

      // Log post-move state
      console.log('Post-move bitboards:', JSON.stringify(newBitboards, (_, v) => 
          typeof v === 'bigint' ? v.toString() : v, 2));
      
      console.groupEnd();

      // Create the next history entry
      const newHistoryEntry = {
          bitboards: newBitboards,
          occupied: newOccupied,
          whitePieces: newWhitePieces,
          blackPieces: newBlackPieces,
          turn: state.turn === "W" ? "B" : "W", // Toggle turn
          castleDirection: newCastleDirection,
          enPassantTargetSq: newEnPassantTargetSq,
          // Keep other state properties like status, promotionSquare if needed
          status: state.status, // Status might change based on checkmate/stalemate checks later
          promotionSquare: state.promotionSquare, // Should be handled by UI flow triggering the move
      };

      history = [...history, newHistoryEntry];
      movesList = [...movesList, newMoveNotation];

      // Return the updated state, spreading the latest history entry for easy access
      return {
          ...state, // Keep things like candidateMoves, can_automate
          ...newHistoryEntry, // Spread the latest board state and turn etc.
          history,
          movesList,
          candidateMoves: [], // Clear candidate moves after a move is made
      };
    }

    case actionTypes.GENERATE_CANDIDATE_MOVES: {
      return { ...state, candidateMoves: action.payload.candidateMoves };
    }
    /* Undo moves (Take Back) */
    case actionTypes.TAKE_BACK: {
      let { history, movesList } = state;

      // Decide how many moves to undo. Original code undid 2 half-moves.
      const numMovesToUndo = 2; // Or 1 if preferred

      if (history.length > numMovesToUndo) {
        history = history.slice(0, history.length - numMovesToUndo);
        movesList = movesList.slice(0, movesList.length - numMovesToUndo);
      } else if (history.length > 1) { // Can only undo down to the initial state
        history = history.slice(0, 1);
        movesList = [];
      }

      // Return state with the new latest history entry spread to top level
      const latestState = history[history.length - 1];
      return {
          ...state, // Keep non-history related state
          ...latestState, // Spread the restored board state, turn, etc.
          history,
          movesList,
          candidateMoves: [], // Clear candidate moves after take back
        };
    }

    case actionTypes.CLEAR_CANDIDATE_MOVES: {
      return { ...state, candidateMoves: [] };
    }
    case actionTypes.OPEN_PROMOTION: {
      return {
        ...state,
        status: Status.promoting,
        promotionSquare: { ...action.payload },
      };
    }

    case actionTypes.CLOSE_PROMOTION: {
      return { ...state, status: Status.ongoing, promotionSquare: null };
    }

    case actionTypes.CAN_CASTLE: {
      let { turn, castleDirection } = state;
      castleDirection[turn] = action.payload;
      return { ...state, castleDirection };
    }
    case actionTypes.STALEMATE: {
      return { ...state, status: Status.stalemate };
    }

    case actionTypes.INSUFFICIENT_MATERIAL: {
      return { ...state, status: Status.insufficient };
    }

    case actionTypes.WIN: {
      return {
        ...state,
        status: action.payload === "W" ? Status.white : Status.black,
      };
    }

    case actionTypes.NEW_GAME: {
      // Reset state using initGameState from constant.js
      // Ensure initGameState itself is spread correctly if needed at top level
      const initial = initGameState;
      const latest = initial.history[0];
      return { ...initial, ...latest }; // Spread initial state and its first history entry
    }
    
    case actionTypes.SET_PLAYER_COLOR: {
      // Update the player's color
      const { playerColor } = action.payload;
      
      console.log("SET_PLAYER_COLOR action received with color:", playerColor);
      
      // Flip the board if player is black so they see the board from their perspective
      const boardFlipped = playerColor === 'B';
      
      // Create a new state with the color selection
      const newState = { 
        ...state, 
        playerColor,
        colorSelected: true, // Mark that color has been selected
        boardFlipped, // Add flag to indicate if board should be flipped
        // If player is black, AI should make the first move as white
        shouldAutomate: playerColor === 'B'
      };
      
      console.log("New state after SET_PLAYER_COLOR:", {
        playerColor: newState.playerColor,
        boardFlipped: newState.boardFlipped,
        shouldAutomate: newState.shouldAutomate
      });
      
      return newState;
    }
    default:
      return state;
  }
};
